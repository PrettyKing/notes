# 排序算法总结与对比

## 常见排序算法分类

### 1. 比较排序算法

**冒泡排序 (Bubble Sort)**
- **原理**: 相邻元素两两比较，大的往后移
- **时间复杂度**: O(n²) 
- **空间复杂度**: O(1)
- **稳定性**: 稳定
- **特点**: 实现简单，但效率低

**选择排序 (Selection Sort)**
- **原理**: 每次选择最小元素放到已排序部分末尾
- **时间复杂度**: O(n²)
- **空间复杂度**: O(1)
- **稳定性**: 不稳定
- **特点**: 交换次数少，但时间复杂度固定

**插入排序 (Insertion Sort)**
- **原理**: 将元素逐个插入到已排序部分的正确位置
- **时间复杂度**: O(n²)，最好情况O(n)
- **空间复杂度**: O(1)
- **稳定性**: 稳定
- **特点**: 对小数组效率高，适合在线排序

**快速排序 (Quick Sort)**
- **原理**: 分治法，选择基准元素分割数组后递归排序
- **时间复杂度**: 平均O(nlogn)，最坏O(n²)
- **空间复杂度**: O(logn)
- **稳定性**: 不稳定
- **特点**: 平均性能优秀，被广泛使用

**归并排序 (Merge Sort)**
- **原理**: 分治法，将数组分半递归排序后合并
- **时间复杂度**: O(nlogn)
- **空间复杂度**: O(n)
- **稳定性**: 稳定
- **特点**: 时间复杂度稳定，适合大数据集

**堆排序 (Heap Sort)**
- **原理**: 构建最大堆，逐个取出堆顶元素
- **时间复杂度**: O(nlogn)
- **空间复杂度**: O(1)
- **稳定性**: 不稳定
- **特点**: 空间效率高，性能稳定

**希尔排序 (Shell Sort)**
- **原理**: 插入排序的改进版，使用间隔序列
- **时间复杂度**: O(n^1.3) ~ O(n²)
- **空间复杂度**: O(1)
- **稳定性**: 不稳定
- **特点**: 对中等规模数据效果好

### 2. 非比较排序算法

**计数排序 (Counting Sort)**
- **原理**: 统计每个元素出现次数，按顺序输出
- **时间复杂度**: O(n+k)，k为数据范围
- **空间复杂度**: O(k)
- **稳定性**: 稳定
- **适用**: 整数且范围不大的情况

**桶排序 (Bucket Sort)**
- **原理**: 将元素分到若干桶中，桶内排序后合并
- **时间复杂度**: 平均O(n+k)，最坏O(n²)
- **空间复杂度**: O(n+k)
- **稳定性**: 稳定
- **适用**: 数据分布均匀的情况

**基数排序 (Radix Sort)**
- **原理**: 按位排序，从低位到高位逐位进行
- **时间复杂度**: O(d×n)，d为位数
- **空间复杂度**: O(n+k)
- **稳定性**: 稳定
- **适用**: 整数或字符串排序

## 排序算法对比表

| 算法 | 平均时间 | 最坏时间 | 空间复杂度 | 稳定性 | 适用场景 |
|------|----------|----------|------------|--------|----------|
| 冒泡排序 | O(n²) | O(n²) | O(1) | 稳定 | 教学演示 |
| 选择排序 | O(n²) | O(n²) | O(1) | 不稳定 | 内存受限 |
| 插入排序 | O(n²) | O(n²) | O(1) | 稳定 | 小数组、部分有序 |
| 快速排序 | O(nlogn) | O(n²) | O(logn) | 不稳定 | 通用，平均性能好 |
| 归并排序 | O(nlogn) | O(nlogn) | O(n) | 稳定 | 大数据、要求稳定 |
| 堆排序 | O(nlogn) | O(nlogn) | O(1) | 不稳定 | 内存受限、性能稳定 |
| 计数排序 | O(n+k) | O(n+k) | O(k) | 稳定 | 整数、范围小 |
| 基数排序 | O(d×n) | O(d×n) | O(n+k) | 稳定 | 整数、多位数 |

## 选择建议

**小数据集 (n < 50)**: 插入排序
**中等数据集**: 快速排序
**大数据集**: 归并排序或堆排序
**需要稳定排序**: 归并排序或计数排序
**内存受限**: 堆排序或希尔排序
**特殊数据类型**: 计数排序、桶排序或基数排序
