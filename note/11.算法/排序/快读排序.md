基本思想是选择一个元素作为"基准"，然后将数组分为两个部分：一个部分包含所有小于基准的元素，另一个部分包含所有大于基准的元素。然后，对这两部分进行递归排序。

```js
function quickSort(array) {
  if (array.length <= 1) {
    return array;
  }

  let pivotIndex = Math.floor(array.length / 2);
  let pivot = array.splice(pivotIndex, 1)[0];
  let left = [];
  let right = [];

  for (let i = 0; i < array.length; i++) {
    if (array[i] < pivot) {
      left.push(array[i]);
    } else {
      right.push(array[i]);
    }
  }

  return quickSort(left).concat([pivot], quickSort(right));
}

let arr = [5, 3, 7, 4, 1, 9, 2, 6, 8];
console.log(quickSort(arr)); // 输出: [1, 2, 3, 4, 5, 6, 7, 8, 9]
```

选取基准元素(pivot)的策略可以有很多种，选取数组中点作为基准只是其中一种。实际上，你可以选择任何一个元素作为基准。

理论上，选取的基准越接近于数组的中值（median），快速排序的效率越高。如果每次都能选中中值作为基准，那么每次都能将数组一分为二，从而最大程度地利用了分治策略，达到最优的 O(n log n) 时间复杂度。

值得注意的是，如果我们每次都选取第一个元素或最后一个元素作为基准，那么在处理已经有序的数组时，快速排序将退化为 O(n^2) 的时间复杂度。基本没有利用到分治策略。

所以说，选取数组中间的元素作为基准，是一种相对比较平衡的策略。

选择一个基准元素（pivot）并将数组分割为两部分，一部分包含所有小于基准的元素，另一部分包含所有大于基准的元素。这个步骤需要遍历整个数组，所以它的时间复杂度是 O(n)。

因为我们每次都将数组分成两部分，所以排序的深度（也就是递归的层数）是 log n。因此，总的时间复杂度是每层的时间复杂度（O(n)）乘以总的层数（log n），得到 O(n log n)。

假设我们有一个已经升序排序的数组，如 [1, 2, 3, 4, 5]，并且我们总是选择第一个元素作为基准。在第一次分割之后，我们得到两个子数组：一个空的数组，另一个包含 [2, 3, 4, 5] 的数组。可以看到，这个分割是非常不均衡的。

然后我们对 [2, 3, 4, 5] 这个数组进行快速排序。我们又选择第一个元素（现在是 2）作为基准，再次分割，我们又得到两个子数组：一个空的数组，另一个包含 [3, 4, 5] 的数组。如此反复进行，我们总是有一个空的子数组，另一个子数组的大小减少 1。

这就意味着，我们必须进行 n 次分割操作才能完成整个数组的排序。而每次分割，我们都需要遍历剩下的 n-1、n-2、n-3...个元素。所以总的操作次数（即时间复杂度）就是 n + (n - 1) + (n - 2) + ... + 1，这就是等差数列的求和，结果是 (n^2 + n) / 2，所以时间复杂度是 O(n^2)。

在最优情况下，也就是每次我们都能均匀地将数组分成两部分，递归的深度就是 log(n)，所以此时的空间复杂度为 O(log n)。这是因为在递归过程中，我们需要为每一层的递归调用分配栈空间。

然而，在最坏的情况下，也就是每次我们都将数组分成一个元素和剩下的 n-1 个元素两部分（如在已经排序的数组中总是选择第一个或最后一个元素为基准），递归的深度就是 n，所以此时的空间复杂度为 O(n)。
