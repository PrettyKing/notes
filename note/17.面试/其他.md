在面试中总结函数式编程时，可以从以下几个层面来回答：

## 核心定义

函数式编程是一种编程范式，它将计算过程视为数学函数的求值，强调使用函数来构建程序，避免改变状态和可变数据。

## 关键特征

**纯函数（Pure Functions）**

- 相同输入总是产生相同输出
- 没有副作用，不修改外部状态
- 便于测试和推理

**不可变性（Immutability）**

- 数据一旦创建就不能修改
- 需要改变时创建新的数据结构
- 避免了并发问题和意外的状态变化

**高阶函数（Higher-order Functions）**

- 函数可以作为参数传递
- 函数可以作为返回值
- 支持函数组合和抽象

## 常见技术

**函数组合**：将多个简单函数组合成复杂功能 **柯里化**：将多参数函数转换为单参数函数序列 **Map/Filter/Reduce**：数据处理的基本操作模式

## 优势与挑战

**优势**：代码更可预测、易于测试、并行处理友好、模块化程度高

**挑战**：学习曲线陡峭、某些场景下性能开销、与传统面向对象思维差异较大

## 应用场景

数据处理、并发编程、数学计算、前端状态管理等领域特别适合函数式方法。

这样的总结既体现了理论理解，又展现了实践认知，会给面试官留下良好印象。


在React中调用`setState`（或函数组件中的`setData`）时，会发生以下过程：

## 1. 状态更新入队
```javascript
const [data, setData] = useState(initialValue);
setData(newValue); // 这里发生了什么？
```

- React将这次状态更新放入更新队列中
- **不会立即更新状态**，而是标记组件需要重新渲染

## 2. 调度阶段（Scheduling）
- React的调度器（Scheduler）决定何时处理这次更新
- 根据优先级（如用户交互 > 数据获取）来安排更新顺序
- 可能会批量处理多个状态更新

## 3. 协调阶段（Reconciliation）
```javascript
// React会比较新旧状态
const newState = typeof newValue === 'function' 
  ? newValue(prevState) 
  : newValue;

// 如果状态确实发生变化（Object.is比较）
if (!Object.is(prevState, newState)) {
  // 标记组件需要重新渲染
}
```

## 4. 重新渲染
- 重新执行函数组件
- 计算新的虚拟DOM
- 与之前的虚拟DOM进行diff比较

## 5. 提交阶段（Commit）
- 将变化应用到真实DOM
- 执行副作用（useEffect等）
- 调用生命周期方法

## 关键特点

**异步更新**：
```javascript
setData(1);
console.log(data); // 仍然是旧值！
```

**批量更新**：
```javascript
setData(1);
setOtherData(2); 
// React会批量处理这两个更新，只触发一次重渲染
```

**函数式更新**：
```javascript
setData(prev => prev + 1); // 确保基于最新状态更新
```

这个过程体现了React的声明式特性和性能优化策略。

`useEffect` 是 React Hooks 中处理副作用的核心 Hook，可以看作是类组件中生命周期方法的函数式替代。

## 基本语法

```javascript
import { useEffect } from 'react';

useEffect(() => {
  // 副作用逻辑
  return () => {
    // 清理函数（可选）
  };
}, [dependencies]); // 依赖数组（可选）
```

## 主要用途

**数据获取**
```javascript
useEffect(() => {
  fetch('/api/data')
    .then(res => res.json())
    .then(data => setData(data));
}, []); // 空依赖数组，仅在挂载时执行
```

**订阅事件**
```javascript
useEffect(() => {
  const handleResize = () => setWindowWidth(window.innerWidth);
  window.addEventListener('resize', handleResize);
  
  return () => {
    window.removeEventListener('resize', handleResize);
  };
}, []);
```

**定时器**
```javascript
useEffect(() => {
  const timer = setInterval(() => {
    setCount(prev => prev + 1);
  }, 1000);
  
  return () => clearInterval(timer);
}, []);
```

## 依赖数组的不同形式

**无依赖数组**：每次渲染都执行
```javascript
useEffect(() => {
  console.log('每次渲染都执行');
});
```

**空依赖数组**：仅在挂载和卸载时执行
```javascript
useEffect(() => {
  console.log('仅挂载时执行一次');
}, []);
```

**有依赖项**：依赖项变化时执行
```javascript
useEffect(() => {
  console.log('count变化时执行');
}, [count]);
```

## 执行时机

1. **挂载后**：组件首次渲染完成后
2. **更新后**：依赖项变化导致组件重新渲染后
3. **卸载前**：清理函数在组件卸载前执行

## 常见模式

**条件执行**
```javascript
useEffect(() => {
  if (user) {
    fetchUserData(user.id);
  }
}, [user]);
```

**多个 useEffect 分离关注点**
```javascript
// 数据获取
useEffect(() => {
  fetchData();
}, []);

// 事件监听
useEffect(() => {
  document.addEventListener('click', handleClick);
  return () => document.removeEventListener('click', handleClick);
}, []);
```

## 注意事项

- **避免无限循环**：确保依赖数组正确设置
- **清理副作用**：防止内存泄漏
- **ESLint 规则**：使用 `exhaustive-deps` 规则检查依赖

`useEffect` 让函数组件能够执行副作用操作，是 React 函数式编程范式的重要组成部分。