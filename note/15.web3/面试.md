# Web3钱包前端开发面试题及答案

## 一、Chrome插件开发相关

### 1. 请介绍Chrome插件的基本架构
**答案：**
Chrome插件主要由以下几个部分组成：
- **Manifest.json**：插件配置文件，定义权限、脚本、页面等
- **Background Script**：后台脚本，处理事件监听、数据持久化
- **Content Script**：注入到网页中的脚本，可访问DOM但运行在隔离环境
- **Popup**：点击插件图标弹出的页面
- **Options Page**：插件设置页面

通信方式：
- Background ↔ Popup：chrome.runtime.sendMessage
- Background ↔ Content Script：chrome.tabs.sendMessage
- Content Script ↔ Web Page：window.postMessage

### 2. 插件如何与网页进行安全通信？
**答案：**
```javascript
// Content Script 注入 Provider
const script = document.createElement('script');
script.src = chrome.runtime.getURL('inpage.js');
document.head.appendChild(script);

// 通过 window.postMessage 通信
window.addEventListener('message', (event) => {
  if (event.source === window && event.data.type === 'FROM_PAGE') {
    chrome.runtime.sendMessage(event.data);
  }
});

// 网页端
window.ethereum = {
  request: (params) => {
    return new Promise((resolve, reject) => {
      window.postMessage({
        type: 'FROM_PAGE',
        method: params.method,
        params: params.params
      });
    });
  }
};
```

### 3. 如何优化插件的性能？
**答案：**
- **代码分割**：使用动态import按需加载
- **Bundle优化**：Tree shaking、压缩、去重
- **内存管理**：及时清理事件监听器、定时器
- **缓存策略**：合理使用chrome.storage缓存数据
- **懒加载**：非核心功能延迟初始化
- **Web Workers**：耗时计算放到Worker中执行

## 二、Web3钱包业务逻辑

### 4. 钱包的助记词是如何生成和管理的？
**答案：**
```javascript
import * as bip39 from 'bip39';
import { hdkey } from 'ethereumjs-wallet';

// 生成助记词
const mnemonic = bip39.generateMnemonic(128); // 12个单词

// 从助记词生成种子
const seed = bip39.mnemonicToSeedSync(mnemonic);

// 生成HD钱包
const hdWallet = hdkey.fromMasterSeed(seed);

// 推导账户 (BIP44路径: m/44'/60'/0'/0/index)
const derivePath = `m/44'/60'/0'/0/0`;
const wallet = hdWallet.derivePath(derivePath).getWallet();
const address = wallet.getAddressString();
const privateKey = wallet.getPrivateKeyString();
```

**安全存储：**
- 助记词使用用户密码+盐值进行AES加密
- 私钥存储在chrome.storage.local中，加密后存储
- 永远不明文存储敏感信息

### 5. 如何实现多链账户管理？
**答案：**
```javascript
// 链配置
const CHAIN_CONFIGS = {
  ethereum: {
    chainId: 1,
    derivePath: "m/44'/60'/0'/0",
    rpcUrl: 'https://mainnet.infura.io/v3/...'
  },
  bsc: {
    chainId: 56,
    derivePath: "m/44'/60'/0'/0", // BSC使用相同路径
    rpcUrl: 'https://bsc-dataseed1.binance.org'
  },
  polygon: {
    chainId: 137,
    derivePath: "m/44'/60'/0'/0",
    rpcUrl: 'https://polygon-rpc.com'
  }
};

class MultiChainWallet {
  constructor(mnemonic) {
    this.hdWallet = hdkey.fromMasterSeed(bip39.mnemonicToSeedSync(mnemonic));
    this.accounts = {};
  }

  getAccount(chainName, index = 0) {
    const config = CHAIN_CONFIGS[chainName];
    const path = `${config.derivePath}/${index}`;
    
    if (!this.accounts[`${chainName}_${index}`]) {
      const wallet = this.hdWallet.derivePath(path).getWallet();
      this.accounts[`${chainName}_${index}`] = {
        address: wallet.getAddressString(),
        privateKey: wallet.getPrivateKeyString(),
        chainId: config.chainId
      };
    }
    
    return this.accounts[`${chainName}_${index}`];
  }
}
```

### 6. 交易签名流程是如何实现的？
**答案：**
```javascript
import { Transaction } from 'ethereumjs-tx';

async function signTransaction(txData, privateKey, chainId) {
  // 1. 构造交易对象
  const tx = new Transaction({
    nonce: txData.nonce,
    gasPrice: txData.gasPrice,
    gasLimit: txData.gasLimit,
    to: txData.to,
    value: txData.value,
    data: txData.data
  }, { chain: chainId });

  // 2. 使用私钥签名
  const privateKeyBuffer = Buffer.from(privateKey.slice(2), 'hex');
  tx.sign(privateKeyBuffer);

  // 3. 获取签名后的交易
  const serializedTx = tx.serialize();
  const rawTransaction = '0x' + serializedTx.toString('hex');

  return {
    rawTransaction,
    txHash: '0x' + tx.hash().toString('hex')
  };
}

// 发送交易
async function sendTransaction(signedTx, rpcUrl) {
  const response = await fetch(rpcUrl, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      jsonrpc: '2.0',
      method: 'eth_sendRawTransaction',
      params: [signedTx.rawTransaction],
      id: 1
    })
  });
  
  const result = await response.json();
  return result.result;
}
```

## 三、安全相关

### 7. 钱包有哪些主要的安全风险点？
**答案：**
**技术风险：**
- 私钥泄露：明文存储、内存泄露、网络传输
- XSS攻击：恶意脚本窃取敏感信息
- 中间人攻击：RPC通信被劫持
- 恶意DApp：诱导用户签名危险交易

**业务风险：**
- 钓鱼网站：伪造知名DApp界面
- 社会工程学：诱导用户泄露助记词
- 恶意合约：无限授权、重入攻击
- Gas费操纵：设置过高手续费

**防护措施：**
- 加密存储、权限隔离、交易确认、白名单机制

### 8. 如何防止私钥泄露？
**答案：**
```javascript
// 1. 加密存储
class SecureStorage {
  static async encrypt(data, password) {
    const salt = crypto.getRandomValues(new Uint8Array(16));
    const key = await crypto.subtle.importKey(
      'raw',
      new TextEncoder().encode(password),
      'PBKDF2',
      false,
      ['deriveBits']
    );
    
    const derivedKey = await crypto.subtle.deriveBits(
      { name: 'PBKDF2', salt, iterations: 100000, hash: 'SHA-256' },
      key,
      256
    );
    
    const aesKey = await crypto.subtle.importKey(
      'raw', derivedKey, 'AES-GCM', false, ['encrypt']
    );
    
    const iv = crypto.getRandomValues(new Uint8Array(12));
    const encrypted = await crypto.subtle.encrypt(
      { name: 'AES-GCM', iv },
      aesKey,
      new TextEncoder().encode(data)
    );
    
    return { encrypted, salt, iv };
  }
}

// 2. 内存安全
class SecureMemory {
  constructor() {
    this.sensitiveData = new Map();
    this.timers = new Map();
  }
  
  store(key, value, ttl = 300000) { // 5分钟过期
    this.sensitiveData.set(key, value);
    
    // 设置自动清除
    const timer = setTimeout(() => {
      this.clear(key);
    }, ttl);
    
    this.timers.set(key, timer);
  }
  
  clear(key) {
    if (this.timers.has(key)) {
      clearTimeout(this.timers.get(key));
      this.timers.delete(key);
    }
    this.sensitiveData.delete(key);
  }
}

// 3. 操作确认
class TransactionSigner {
  async signWithConfirmation(txData, privateKey) {
    // 显示交易详情给用户确认
    const confirmed = await this.showConfirmationDialog(txData);
    if (!confirmed) {
      throw new Error('User rejected transaction');
    }
    
    return this.signTransaction(txData, privateKey);
  }
}
```

## 四、架构设计

### 9. 如何设计一个支持多链的钱包插件架构？
**答案：**
```
src/
├── background/           # 后台脚本
│   ├── wallet-manager.js    # 钱包管理
│   ├── chain-manager.js     # 链管理
│   └── transaction-queue.js # 交易队列
├── content/             # 内容脚本
│   ├── provider-injector.js # Provider注入
│   └── dapp-detector.js     # DApp检测
├── popup/               # 弹窗页面
│   ├── components/         # React组件
│   └── pages/             # 页面
├── shared/              # 共享模块
│   ├── crypto/            # 加密相关
│   ├── chains/            # 链配置
│   └── storage/           # 存储管理
└── inpage/              # 注入脚本
    └── ethereum-provider.js
```

**核心模块设计：**
```javascript
// 抽象链接口
interface IChainAdapter {
  getBalance(address: string): Promise<string>;
  sendTransaction(tx: TransactionRequest): Promise<string>;
  signMessage(message: string, privateKey: string): Promise<string>;
}

// EVM链适配器
class EVMChainAdapter implements IChainAdapter {
  constructor(private config: ChainConfig) {}
  
  async getBalance(address: string): Promise<string> {
    const response = await this.rpcCall('eth_getBalance', [address, 'latest']);
    return response.result;
  }
}

// 链管理器
class ChainManager {
  private adapters = new Map<string, IChainAdapter>();
  
  registerChain(name: string, adapter: IChainAdapter) {
    this.adapters.set(name, adapter);
  }
  
  getAdapter(chainName: string): IChainAdapter {
    return this.adapters.get(chainName);
  }
}
```

### 10. DApp浏览器如何实现？
**答案：**
```javascript
// 内置DApp浏览器架构
class DAppBrowser {
  constructor() {
    this.webview = null;
    this.providerInjected = false;
  }
  
  // 创建沙盒环境
  createSandbox(url) {
    this.webview = document.createElement('webview');
    this.webview.src = url;
    this.webview.partition = 'persist:dapp';
    
    // 注入Provider
    this.webview.addEventListener('dom-ready', () => {
      this.injectProvider();
    });
    
    return this.webview;
  }
  
  // 注入Web3 Provider
  injectProvider() {
    const injectionScript = `
      window.ethereum = {
        isMetaMask: true,
        request: async (args) => {
          return new Promise((resolve, reject) => {
            const id = Math.random().toString(36);
            window.addEventListener('message', function handler(event) {
              if (event.data.id === id) {
                window.removeEventListener('message', handler);
                if (event.data.error) {
                  reject(new Error(event.data.error));
                } else {
                  resolve(event.data.result);
                }
              }
            });
            
            window.postMessage({
              type: 'ETHEREUM_REQUEST',
              id: id,
              method: args.method,
              params: args.params
            });
          });
        }
      };
    `;
    
    this.webview.executeScript({ code: injectionScript });
  }
}
```

## 五、性能优化

### 11. 如何优化钱包插件的启动性能？
**答案：**
**代码层面：**
```javascript
// 1. 懒加载模块
const loadCryptoModule = () => import('./crypto/index.js');
const loadChainModule = (chainName) => import(`./chains/${chainName}.js`);

// 2. 异步初始化
class WalletManager {
  constructor() {
    this.initialized = false;
    this.initPromise = null;
  }
  
  async ensureInitialized() {
    if (this.initialized) return;
    if (this.initPromise) return this.initPromise;
    
    this.initPromise = this.initialize();
    await this.initPromise;
  }
  
  async initialize() {
    // 只加载必要的链
    const activeChains = await this.getActiveChains();
    await Promise.all(
      activeChains.map(chain => this.loadChain(chain))
    );
    this.initialized = true;
  }
}

// 3. 缓存优化
class CacheManager {
  constructor() {
    this.cache = new Map();
    this.ttl = new Map();
  }
  
  set(key, value, ttl = 60000) {
    this.cache.set(key, value);
    this.ttl.set(key, Date.now() + ttl);
  }
  
  get(key) {
    if (this.ttl.get(key) < Date.now()) {
      this.cache.delete(key);
      this.ttl.delete(key);
      return null;
    }
    return this.cache.get(key);
  }
}
```

**Bundle优化：**
```javascript
// webpack.config.js
module.exports = {
  optimization: {
    splitChunks: {
      chunks: 'all',
      cacheGroups: {
        vendor: {
          test: /[\\/]node_modules[\\/]/,
          name: 'vendors',
          chunks: 'all',
        },
        crypto: {
          test: /[\\/]src[\\/]crypto[\\/]/,
          name: 'crypto',
          chunks: 'all',
        }
      }
    }
  }
};
```

### 12. 如何处理大量交易记录的性能问题？
**答案：**
```javascript
// 虚拟滚动
class VirtualList {
  constructor(container, itemHeight, renderItem) {
    this.container = container;
    this.itemHeight = itemHeight;
    this.renderItem = renderItem;
    this.scrollTop = 0;
    this.containerHeight = container.clientHeight;
  }
  
  render(data) {
    const visibleStart = Math.floor(this.scrollTop / this.itemHeight);
    const visibleEnd = Math.min(
      visibleStart + Math.ceil(this.containerHeight / this.itemHeight) + 1,
      data.length
    );
    
    // 只渲染可见区域的项目
    const visibleItems = data.slice(visibleStart, visibleEnd);
    this.container.innerHTML = visibleItems
      .map((item, index) => this.renderItem(item, visibleStart + index))
      .join('');
  }
}

// 分页加载
class TransactionManager {
  async loadTransactions(address, page = 1, limit = 20) {
    const cacheKey = `tx_${address}_${page}`;
    const cached = this.cache.get(cacheKey);
    if (cached) return cached;
    
    const transactions = await this.fetchTransactions(address, page, limit);
    this.cache.set(cacheKey, transactions);
    return transactions;
  }
}
```

## 六、实际项目经验

### 13. 遇到过哪些技术难点，如何解决的？
**答案示例：**

**难点1：多链Gas费估算差异**
- 问题：不同链的Gas机制不同（如ETH的EIP-1559 vs BSC的传统模式）
- 解决：抽象Gas估算接口，各链实现自己的策略
```javascript
class GasEstimator {
  async estimateGas(chainId, txData) {
    const strategy = this.getStrategy(chainId);
    return strategy.estimate(txData);
  }
  
  getStrategy(chainId) {
    switch (chainId) {
      case 1: return new EIP1559GasStrategy();
      case 56: return new LegacyGasStrategy();
      default: return new DefaultGasStrategy();
    }
  }
}
```

**难点2：DApp兼容性问题**
- 问题：某些DApp依赖特定的MetaMask行为
- 解决：详细分析MetaMask源码，模拟其行为模式

**难点3：交易状态同步**
- 问题：多个页面同时操作时状态不一致
- 解决：使用事件总线和状态管理
```javascript
class StateManager {
  constructor() {
    this.state = new Proxy({}, {
      set: (target, key, value) => {
        target[key] = value;
        this.emit('stateChange', { key, value });
        return true;
      }
    });
  }
  
  emit(event, data) {
    chrome.runtime.sendMessage({ type: event, data });
  }
}
```

### 14. 如何保证代码质量和可维护性？
**答案：**

**代码规范：**
- 使用TypeScript进行类型检查
- ESLint + Prettier统一代码风格
- 详细的注释和文档

**测试策略：**
```javascript
// 单元测试
describe('WalletManager', () => {
  test('should generate correct address from mnemonic', () => {
    const wallet = new WalletManager(TEST_MNEMONIC);
    const address = wallet.getAddress('ethereum', 0);
    expect(address).toBe(EXPECTED_ADDRESS);
  });
});

// 集成测试
describe('Transaction Flow', () => {
  test('should complete full transaction flow', async () => {
    const tx = await walletManager.createTransaction(txData);
    const signed = await walletManager.signTransaction(tx);
    const result = await walletManager.sendTransaction(signed);
    expect(result.status).toBe('success');
  });
});
```

**架构设计：**
- 模块化设计，单一职责原则
- 依赖注入，便于测试和扩展
- 抽象接口，支持多种实现